Test network blockchain
A test network blockchain, also known as a testnet, is a replica of a main blockchain network that operates independently, allowing developers to test and experiment with blockchain applications without risking real funds or the main chain. Testnets are used to deploy, test, and execute projects on a functioning blockchain network, ensuring that the blockchain’s functionality and performance are thoroughly tested before its launch.

Key Characteristics:

Operates on a separate ledger from the mainnet
Coins on a testnet have no connection to transactions and value on the mainnet
Allows developers to deploy, test, and execute projects on a functioning blockchain network
blockchain technology?
A faucet in blockchain is a website or application that gives away small amounts of cryptocurrency, such as Bitcoin, Ethereum, or other altcoins, in exchange for completing simple tasks.
2.Specific hash functions are used to create hash for data/transactions
3.genesis block-first block in blockchain
4.Nonce in blockchain
A nonce, short for “number used once,” is a critical component in blockchain technology, particularly in proof-of-work (PoW) chains like Bitcoin. It is a randomly generated number that is added to a block of data before it is hashed. The purpose of the nonce is to make it difficult for someone to tamper with the data in the block and manipulate the blockchain.
How Nonce Works
In the process of mining a block, miners test and discard millions of nonces per second until they find a valid one. The nonce is used to modify the input to a cryptographic hash function, which makes it difficult to find a valid hash that meets the network’s difficulty criteria. Once a valid nonce is found, the miner can complete the block and add it to the blockchain, earning a block reward in the process.
Importance of Nonce
The nonce plays a vital role in ensuring the security, transparency, and trustworthiness of blockchain systems. It is a critical component of the proof-of-work consensus algorithm, which is used to validate and add new transactions to the blockchain. The nonce helps to prevent tampering with the data in the block and ensures that the blockchain remains secure and tamper-proof.
5.A private key is an essential component of blockchain technology, serving as a unique identifier for a user’s cryptocurrency wallet. It is used to authorize transactions, prove ownership of a blockchain address, and maintain the security of a user’s digital assets.
What is a Private Key?
A private key is an alphanumeric code generated by a cryptocurrency wallet. It is used to authorize transactions and prove ownership of a blockchain asset. A private key is an integral part of cryptocurrency, and its encrypted properties help protect users from thieves and unauthorized access to their funds.
How Does a Private Key Work?
A private key is used to sign transactions, which verifies the ownership of a blockchain address. When a user sends cryptocurrency, the private key is used to create a digital signature, which is then transmitted along with the transaction to the blockchain network. This signature ensures that the transaction has come from the user and prevents it from being altered by anyone once it has been issued.
6.private key|||>public key>adress
7.consensus is the mechanism used to agree o the state of the blockcchain
8.Blockchain mining is the process of verifying and adding new transactions to a blockchain, a decentralized and distributed digital ledger. It is a crucial component of cryptocurrency systems, such as Bitcoin, Ethereum, and others. Miners use powerful computers to solve complex mathematical problems, which helps to secure the network and validate transactions.
How Does Blockchain Mining Work?
Here’s a step-by-step explanation:
Transactions: When a user initiates a transaction, it is broadcast to the network.
Verification: Miners collect and verify the transactions to ensure their validity and legitimacy.
Block creation: Miners group verified transactions into a block, which is a container for multiple transactions.
Hash function: Miners use a cryptographic hash function to create a unique digital fingerprint, or “hash,” for each block.
Proof-of-work: Miners compete to find a hash that meets a specific criteria, known as a “proof-of-work.” This requires significant computational power.
Block validation: The miner who finds the correct hash first gets to add the block to the blockchain and is rewarded with newly minted coins or transaction fees.
Blockchain update: The updated blockchain is distributed to the network, ensuring that all nodes have the same version of the blockchain.
Types of Blockchain Mining
Proof-of-work (PoW): The most common method, used by Bitcoin and other cryptocurrencies. Miners compete to find a hash that meets a specific criteria.
Proof-of-stake (PoS): Used by some cryptocurrencies, such as Ethereum. Miners are chosen to create a new block based on the amount of cryptocurrency they hold (i.e., their “stake”).
Delegated proof-of-stake (DPoS): A variant of PoS, where users vote for validators to create new blocks.
9.types of attack on blockcahin
--sybil attack
--51% attack
longest chain rule(the bigger the blockchain the harder it is to influence it )
10.proof of stake uses much lees energy than prrof of work
11.miners are validators
12.sharding removes the issue of  blockcahin scalability(gas prices going high becuase of demand(blocks have limited blocksspace )
13.layer 1:base layer blockchain imlplmentation                                                       
Layer 1 in blockchain refers to the foundational level of blockchain architecture, operating as the primary and autonomous chain on which transactions are directly executed and confirmed. 
layer 2:Layer 2 in blockchain
Layer 2 in blockchain refers to a secondary framework or protocol that is built on top of an existing blockchain system. The primary goal of these protocols is to address the transaction speed and scaling difficulties faced by major cryptocurrency networks, such as Bitcoin and Ethereum. These networks are still unable to process thousands of transactions per second (TPS), which hinders their long-term growth.
Key Characteristics
Layer 2 protocols are built on top of a Layer 1 blockchain, inheriting its security guarantees.
They often run with smart contracts on their underlying blockchain.
Layer 2 solutions compromise on decentralization and security to achieve speed, making it more risky to store funds on them.  
Why can’t I add Solana to MetaMask?
MetaMask is built specifically for Ethereum and Ethereum Virtual Machine (EVM) compatible chains. In other words, MetaMask is built only for blockchains that can run Ethereum smart contracts. 
Because Solana is not EVM-compatible, MetaMask does not support the ability to hold and trade Solana-based assets. 
Phantom 
Phantom is the most popular software wallet built specifically for the Solana blockchain. Some users even call Phantom the MetaMask of the Solana blockchain! Phantom features a browser extension application and other user-friendly features — like a built-in decentralized exchange and the ability to stake SOL. 
14.SOLIDITY
SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
(these two statements above are mandatory)
 2 ways to store variables--memeory,stroage
memeory-data will only be stored during the execution of the function
storage-data will remain even after the function is executed
2.mapping() -- a dictionary like data structure with one value per key
3.everytime we interact with a contract we need to things ,its adress and ABI(application binary interface
Application Binary Interface (ABI): A software interface between two binary program modules, typically a library or operating system facility and a user program. An ABI defines how data structures or computational procedures are used to communicate between these modules.
---The ABI tells solidity and othe rprogramming languages how to interact with another samrt contract
----Anytime you want to interact with another already deployed smart contract you need and ABI
4.The Orcale problem:-smart contracts are unable to connect with external systems,data feeds,API's
5.Interface complie down to a ABI
6.integers can wrap around after  raeching the limit unit8(initial value 255) will go to 0 if we add 1 to 255 
7.revert and require(like pass and break
8.transfer function can be used to send money between addresses,msg.sender.transfer(adress(this).balance)
9.adress(this).balance ,this points to the contract we are currently in
10.constructor () public{
}
constructor is  called when contract is deployed
inheritence example:
contract exaample is inheritedExample{//here example inherits inheritedExample

}
10.the brownie-config.yaml file is very important(store ur dependencies,networks,wallets etc here)
11.address is a datatype
12.modifier is used to change the behaviour of a function in a declarative way.
13.web3.py is a python libraray to interact  with ethererum
14.brownie -smart contract development framework built on web3.py
15.two types to interact with contract:
--transact and call
call-simulates a call and gets areturn value
--transact--makees a state change
16.brownie is built on web3.py
web3.py code can we written in even easier format using brownie
16.Chainlink price feeds are smart contracts that provide the price of an asset in USD. They use a decentralized model to aggregate data from many sources, such as exchanges, through a network of independent node operators:
17.What are dependencies
Dependencies are relationships between tasks, activities, or products that require input from other tasks, activities, or products to be completed. They are essential in project management, software development, and other fields where multiple components or tasks need to be coordinated.
18.enums are a way to create user defined type sin solidity,enums are explicitily convertible to and from all integer types
19.Chainlink is a decentralized computing platform and cryptocurrency that allows non-blockchain businesses to securely connect with blockchain platforms. It acts as a bridge between the blockchain and the outside world, allowing smart contracts to access real-world data and events
20.we can fork blockchain networks to test and deploy on them
21.brownie chainlink mix
21.ERC-20 i a blueprint for creating fungible tokens
22.Ethereum Request for Comment 20 (ERC20) is a standard for creating fungible tokens on the Ethereum blockchain. It's a set of rules and functions that tokens must follow to ensure they work properly within the Ethereum ecosystem.
23.Tokens can be made out of a smart contract ,some amount of ether is send to the contract,then the contract makes token out of that currency .ERC20  is a guidline to write token contracts.
https://youtu.be/cqZhNzZoMh8?si=O-mp3ZwhSVub5660
24.similarly ERC-721 is a standard guidlinde for NFTS
25.openzepplin
26.Aave is a decentralized crypto lending platform that lets users borrow and lend crypto. Aave uses smart contracts to automate the process.
Aave
Aave is also the name of a DeFi protocol that automates lending with smart contracts. The protocol allows users to borrow assets at interest, with flexible repayment terms and interest rates that adjust based on asset utilization
27.aETH-interest bearing token
28.aave also uses chainlink price feeds
29.testrnet.aave.com
30.app.aave.com
from brownie import config,network,accounts
(inside get_accounts())
if network.show_active()=="development"
       return accounts[0]
30.The LendingPool contract is the main contract of the protocol(aave)(we use function from this contarct to deposit,borrow etc.). It exposes all the user-oriented actions that can be invoked using either Solidity or web3 libraries
31.WETH is the ERC20 version of ETH
32.A DeFi protocol is a set of rules, codes, and procedures that govern systems of lending, borrowing, and trading cryptocurrencies. DeFi protocols are embodied in smart contracts on Ethereum and other programmable blockchains. They are designed to address issues related to the traditional finance industry, such as lack of access to financial services for the unbanked and underbanked population.

DeFi protocols are specialized autonomous programs that enable peer-to-peer transactions, eliminating the need for intermediaries or custodians.\
33.in testing files we use assert
--arrange,act,assert
34.NFTS use ERC721 standard
35.semi fungible tokens -ERC1155
36.ERC20 basically keeps track of the address and how much balance that address has , while ERC721 keeps track of the token ID and the owner of the token(address)
it also has somethinbg called token URI
37.token URI is  just a simplke API call
38.The VRF Coordinator is a contract deployed on a blockchain that checks the randomness of each random number returned from a random node. It is used in Chainlink’s VRF (Verifiable Random Function) system, which provides a secure and decentralized way to generate random numbers.
39.import pytest
inside function if we use pytest.skip() it skips the function.
40.IPFS(Interplanetary file sharing system) a decentralized platform to store files.
41.contractname[-1] gives its latest deployment.
42.put an __init__.py file in scripts folder just in case to let the compiler know we are importing the files in between
for example: from scripts.helpful_scripts import get_account()
43.some keywords in solidity : payable,view ,public,internal,override,private,address,event emit,indexed,modifier,constructor
44.The function selector in Solidity is a 4-byte identifier that Solidity uses to identify functions under the hood. It is how a Solidity contract knows which function you are trying to call in a transaction. The function selector is obtained by hashing the function’s signature, which is a combination of the function’s name and the types of parameters it takes, combined together as a string with no spaces.
Here is an example of how to get the function selector in Solidity:
---------------------------------------------------------------------------------------------
pragma solidity 0.8.25;

contract SelectorTest {
    function foo() public {}

    function getSelectorOfFoo() external pure returns (bytes4) {
        return this.foo.selector;
    }
}
-----------------------------------------------------------------------------------------------
In this example, the getSelectorOfFoo function returns the 4-byte function selector of the foo function.

You can also get the function selector by using the abi.encodeWithSignature function from the OpenZeppelin Solidity library:
------------------------------------------------------------------------------------------
pragma solidity 0.8.25;

import "openzeppelin-solidity/contracts/utils/ABI.sol";

contract SelectorTest {
    function foo() public {}

    function getSelectorOfFoo() external pure returns (bytes4) {
        return ABI.encodeWithSignature("foo(address,uint256)");
    }
}
----------------------------------------------------------------------------------------------------
45.brownie bake chasinlink-mix
   brownie bake upgardes-mix 
we use these to get a more specialized boiler plate structure

46.events allow us to store data on the blockchain ,events are used to note that something happend ,this ia cheap alternative that stroing as state variable.
46.what is event in solidity
Events in Solidity are inheritable members of a contract that store the arguments passed in transaction logs when emitted. These logs are stored on the blockchain and are accessible using the contract’s address until the contract is present on the blockchain. Events are used to inform the calling application about the current state of the contract, with the help of the logging facility of EVM.

Events can be declared using the event keyword and can be called from any method by using its name and passing the required parameters. An event can be defined with indexed parameters, which allows for efficient filtering and retrieval of events by specific criteria.

Here is an example of a Solidity program that demonstrates creating an event:
------------------------------------------------------------------------------------------------------------------------------------
pragma solidity ^0.4.21;

contract eventExample {
    uint256 public value = 0;

    event Increment(address indexed owner); //here indexed is used to filter our data from the front end.

    function getValue(uint _a, uint _b) public {
        emit Increment(msg.sender);
        value = _a + _b;
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------
In this example, the eventExample contract has a state variable value and an event Increment that is emitted when the getValue function is called. The emit statement is used to trigger the event, passing the msg.sender as an argument.

Events are useful for logging important information about the contract’s state and can be used to trigger specific logic in other contracts or applications.
47.Truffle is a development framework and toolset for building decentralized applications (dApps) on the Ethereum blockchain
48.nested mapping :
for example:
mapping token address->staker address->amount
mapping(address  =>mapping( address => uint256 )) public stakingBalance;
updating the amount :
stakingBalance[tokenAdrress][msg.sender]=stakingBalce[tokenAddress][ms.sender] + amount;
49.We cant loop through a mapping.
50.function addAllowTokens() internal{}
here the internal keywor means only the contract in which the function is written can call it.
51.AggregatorV3Interface is used to get price feeds of differenct token
to do this:
import aggregatorV3Interface from chainlink
then 
AggregatorV3Interface priceFeed=AggregatorV3Interface(_tokonAdddress)//getting the price for specific tokens.this line of code is used to make a contract named priceFeed.
(,int256,,,)=priceFeed.latestRoundData();
52.suppose u wanna transfer multiple tokens,call that tokens transfer function for example you wanna unstake the staked tokens then,
IERC20(_tokenAdress).transfer(msg.sender,balance)//_tokenAdress is the address of the token we need to unstake.msg.sender is the address of the person calling the function,the above code will be inside unstakeTokens( function),
53.to mock token inside contract directory we make a test directory and write .sol files for the tokens.(we just need to inherit erc20 after importing it  and the code the constructor )
whenever we write the constructor of an  contract that is inheriting we also include parameters of contract inherited(for example ERC20("TOKEN NAME","TOKEN SYMBOL")
this way our mock token is ready.
54.ideally we want to test all contracts written in one way or another
under tests directory go to unit directory and inside that  we make file tets_token_farm.py(in one python file we write different functions to test different function of solidity contract) to test the token farm contract(we check every function in the contract).
in test we usually split it into three categories (arrange,act,assert)
55.to compile and run scripts we use coomand brownie run pythonFileNmae.py
56.to compile qand run tests we use brownie test pythonFileName.py
if we want to tests only for a specific function we use brownie test -k pythonFunctionName
57.useDapp is a framework/tool(its basically etheruem +React) for Dapp development
58.most applications(Dapps) have different git repos for front end code  and the contracts code.
it is best practise to have frontend code different from contracts.
